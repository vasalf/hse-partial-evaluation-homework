#lang racket

(provide mix-naïve)

(define (initial-block program) '())
(define (init-residual program division) '())
(define (lookup pp program) '())
(define (initial-code pp vs) '())
(define (extend-bb bb cmd) '())
(define (extend-code code bb) '())
(define (first-command bb) '())
(define (bb-tail bb) '())
(define (reduce exp vs) '())
(define (is-static-symb symbol division) '())
(define (is-static-expr epxr division) '())
(define (extend-vs vs x expr) '())
(define (eval-expr expr vs) '())
(define (extend-unmarked pending ps marked) '())
(define (block-name pp vs) '())

(define mix-naïve
  `((import (initial-block   . ,initial-block)
            (init-residual   . ,init-residual)
            (lookup          . ,lookup)
            (inital-code     . ,initial-code)
            (extend-bb       . ,extend-bb)
            (extend-code     . ,extend-code)
            (first-command   . ,first-command)
            (bb-tail         . ,bb-tail)
            (reduce          . ,reduce)
            (is-static-symb  . ,is-static-symb)
            (is-static-expr  . ,is-static-expr)
            (extend-vs       . ,extend-vs)
            (eval-expr       . ,eval-expr)
            (extend-unmarked . ,extend-unmarked)
            (block-name      . ,block-name))
    (read program division vs0)
    (init     (:= pending `((,(initial-block program) . vs0)))
              (:= marked null)
              (:= residual (init-residual program division))
              (goto loop))
    (loop     (if (null? pending) end loopb))
    (loopb        (:= pp (caar pending))
                  (:= vs (cadar pending))
                  (:= pending (cdr pending))
                  (:= marked (cons (pp . vs) marked))
                  (:= bb (lookup pp program))
                  (:= code (initial-code pp vs))
                  (goto loopbb))
    (loopbb       (if (null? bb) endbb loopbbb))
    (loopbbb          (:= command (first-command bb))
                      (:= bb (bb-tail bb))
                      (goto casebb0))
    (casebb0          (if (equal? (car command) 'debug) loopbb casebb1))
    (casebb1          (if (equal? (car command) ':=) cassign casebb2))
    (casebb2          (if (equal? (car command) 'goto) cgoto casebb3))
    (casebb3          (if (equal? (car command) 'if) cif casebb4))
    (casebb4          (if (equal? (car comеmand) 'return) creturn casebb5))
    (casebb5          (return 'error))
    (cassign          (if (is-static-symb (cadr command) division) sassign dassign))
    (sassign          (:= vs (extend-vs vs (cadr command) (caddr command)))
                      (goto loopbb))
    (dassign          (:= x (cadr command))
                      (:= e (caddr command))
                      (:= code (extend-bb code `(:= x ,(reduce e vs))))
                      (goto loopbb))
    (cgoto            (:= bb (lookup (cadr command) program))
                      (goto loopbb))
    (cif              (if (is-static-expr (cadr command) division) sif dif))
    (sif              (if (eval-expr expr vs) sift siff))
    (sift             (:= bb (lookup (caddr command) program))
                      (goto loopbb))
    (siff             (:= bb (lookup (cadddr command) program))
                      (goto loopbb))
    (dif              (:= ift (caddr command))
                      (:= iff (cadddr command))
                      (:= nift (block-name ift vs))
                      (:= niff (block-name iff vs))
                      (:= ps '((ift . vs) (iff . vs)))
                      (:= pending (extend-pending-unmarked pending ps marked))
                      (:= e (reduce (cadr command) vs))
                      (:= code (extend-bb code `(if e nift niff)))
                      (goto loopbb))
    (creturn          (:= code (extend-bb code `(return ,(reduce (cadr command) vs))))
                      (goto loopbb))
    (endbb        (:= residual (extend-code residual code))
                  (goto loop))
    (end      (return residual))
   ))