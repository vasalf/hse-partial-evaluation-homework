#lang racket

(require "flowchart/main.rkt")
(require "flowchart/prettyprint.rkt")
(require "flowchart/fc-int.rkt")
(require "tm/main.rkt")
(require "mix/naive.rkt")
(require "mix/main.rkt")

(define (main)
  (define find-name
    '((read name namelist valuelist)
      (search (if (equal? name (car namelist)) found cont))
      (cont (:= valuelist (cdr valuelist))
            (:= namelist  (cdr namelist))
            (goto search))
      (found (return (car valuelist)))
      ))

  (display "==== HW1 ====\n")
  (display (int find-name '(y (x y z) (1 2 3))))
  (display "\n")

  (define tm-example
    '((0 if 0 goto 3)
      (1 right)
      (2 goto 0)
      (3 write 1)))

  (display (int tm-int `(,tm-example (1 1 1 0 1 0 1))))
  (display "\n\n")

  (display "==== HW2 (big, hard, painful, and a bit philosophical) ====\n")
  (display "I Futamura Projection:\n")
  (define tm-int-division
    '((program ptail curp elem)
      (right left tmp)))
  (define tm-int-vs
    `((program . ,tm-example)
      (ptail . '())
      (curp . '())
      (elem . '())))
  (prettyprint (int mix-naïve `(,tm-int ,tm-int-division ,tm-int-vs)))
  (define interpret (int mix-naïve `(,tm-int ,tm-int-division ,tm-int-vs)))
  (print (int interpret'((1 1 1 0 1 0 1))))

  (display "\n\nII Futamura Projection, naïve version:\n")
  (define mix-naïve-division
    '((program division live-variables)
      (vs0 pending marked residual pp bb vs code command x e ift iff nift niff ps)))
  (define mix-naïve-vs
    `((program . ,tm-int)
      (division . ,tm-int-division)
      (live-variables . ())))
  (define mix-naïve-compiler (int mix-naïve `(,mix-naïve ,mix-naïve-division ,mix-naïve-vs)))
  (prettyprint mix-naïve-compiler)
  (define mix-naïve-tm-program
    (int mix-naïve-compiler `(,tm-int-vs)))
  (prettyprint mix-naïve-tm-program)
  (print (int mix-naïve-tm-program '((1 1 1 0 1 0 1))))
  (display "\n\nAs expected, it did nothing. The reason is that in the naïve mix virtually all variables are dynamic. And the next task is to fix it.\n")

  (display "\nI Futamura Projection:\n")
  (define interpret2 (int mix `(,tm-int ,tm-int-division ,tm-int-vs)))
  (prettyprint interpret2)
  (print (int interpret2 '((1 1 1 0 1 0 1))))

  (display "\n\n II Futamura Projection:\n")
  (define mix-division
    '((program division live-variables labels ppp bb command x e ift iff)
      (vs0 pending marked residual pp vs code nift niff ps ex)))
  (define mix-vs
    `((program . ,tm-int)
      (division . ,tm-int-division)
      (live-variables . ())
      (labels . ())
      (ppp . ())
      (bb . ())
      (command . ())
      (x . ())
      (e . ())
      (ift . ())
      (iff . ())))
  (define mix-compiler (int mix `(,mix ,mix-division ,mix-vs)))
  (prettyprint mix-compiler)
  (define mix-tm-program
    (int mix-compiler `(,tm-int-vs)))
  (prettyprint mix-tm-program)
  (print (int mix-tm-program '((1 1 1 0 1 0 1))))

  (display "\n\nI Futamura Projection (with FC interprer written in FC):\n")
  (define fc-int-division
    '((program read-statement import-statement blocks cur-block bb stmt)
      (data ns)))
  (define fc-int-vs
    `((program . ,find-name)
      (read-statement . ())
      (import-statement . ())
      (blocks . ())
      (cur-block . ())
      (bb . ())
      (stmt . ())))
  (define interpret3 (int mix `(,fc-int ,fc-int-division ,fc-int-vs)))
  (prettyprint interpret3)
  (println (int interpret3 '((y (x y z) (1 2 3)))))
  (display "\nIt isn't fully matched but this version of mix doesn't support dynamic sets of dynamic variables (i.e. depending on values of static variables)\n")

  (display "\n\nII Futamura Projection (with FC interprer written in FC):\n")
  (define mix-vs-fc
    `((program . ,fc-int)
      (division . ,fc-int-division)
      (live-variables . ())
      (labels . ())
      (ppp . ())
      (bb . ())
      (command . ())
      (x . ())
      (e . ())
      (ift . ())
      (iff . ())))
  (define mix-fc-compiler (int mix `(,mix ,mix-division ,mix-vs-fc)))
  (prettyprint mix-fc-compiler)
  (define mix-fc-program
    (int mix-fc-compiler `(,fc-int-vs)))
  (prettyprint mix-fc-program)
  (println (int mix-fc-program '((y (x y z) (1 2 3)))))
  (println (equal? mix-fc-program interpret3))
  (display "\nWe see that two outputs are the same\n")

  (display "\n\nIII Futamura Projection:\n")
  (define mix-fut3-vs
    `((program . ,mix)
      (division . ,mix-division)
      (live-variables . ())
      (labels . ())
      (ppp . ())
      (bb . ())
      (command . ())
      (x . ())
      (e . ())
      (ift . ())
      (iff . ())))
  (define cogen (int mix `(,mix ,mix-division ,mix-fut3-vs)))
  (prettyprint cogen)
  (display "\nTM compiler:\n")
  (define cogen-tm-compiler (int cogen `(,mix-vs)))
  (prettyprint cogen-tm-compiler)
  (define cogen-tm-example (int cogen-tm-compiler `(,tm-int-vs)))
  (prettyprint cogen-tm-example)
  (println (int cogen-tm-example '((1 1 1 0 1 0 1))))
  (println (equal? mix-compiler cogen-tm-compiler))
  (display "\nFC compiler:\n")
  (define cogen-fc-compiler (int cogen `(,mix-vs-fc)))
  (prettyprint cogen-fc-compiler)
  (define cogen-fc-example (int cogen-fc-compiler `(,fc-int-vs)))
  (prettyprint cogen-fc-example)
  (println (int cogen-fc-example '((y (x y z) (1 2 3)))))
  (println (equal? cogen-fc-example mix-fc-program))
  (display "\nThe most exciting thing is that the generated programs are the same.\n")
)

(main)
